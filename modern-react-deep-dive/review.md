

<img width="640" height="480" alt="image" src="https://github.com/user-attachments/assets/faa2b245-ac80-4cd9-a105-d388adb792d0" />


## 들어가며  

### 왜 리액트인가?, 리액트의 역사

- 리액트는 단방향 바인딩만 지원한다. 단방향 바인딩이란 말 그대로 데이터의 흐름이 한쪽으로만 가는 것이다. 리액트의 상태변화는 '단방향'으로 그리고 '명시적'으로 이루어진다. 상태가 변화했다면 그 상태변화를 명시적으로 일으키는 함수만 찾으면 된다.
- 브라우저와 생태계의 변화에 맞춰 서버에서 생성한 HTML 페이지를 보여주고 간단한 폼 처리 정도만 하던 브라우저 환경은 급변하기 시작했다. 자바스크립트는 적극적으로 DOM(Document Object Model)을 수정해 사용자에게 다양한 인터랙션을 보여주었고 Ajax를 활용해 서버뿐만 아니라 클라이언트에서도 서버와 통신해서 데이터를 불러오기 시작했다.

<br/>

## 1장 리액트 개발을 위해 꼭 알아야할 자바스크립트

- 리액트 컴포넌트 렌더링이 일어나는 이유 중 하나가 바로 props의 동등 비교에 따른 결과다. 그리고 이 props의 동등비교는 객체의 얕은 비교를 기반으로 이루어지는데 이 얕은 비교가 리액트에서 어떻게 작동하는지 이해하지 못하면 렌더링 최적화에 어려움을 겪을 가능성이 크다.
- 자바스크립트의 모든 값은 데이터 타입을 갖고 있으며 크게 원시 타입과 객체 타입으로 나눌 수 있다.
- 원시타입이란 간단히 정의하자면 객체가 아닌 다른 모든 타입을 의미한다. 객체가 아니므로 이러한 타입들은 메서드를 갖지 않는다.
- 원시타입 중 하나인 null이 가지고 있는 특별한 점 하나는 다른 원시값과 다르게 typeof로 null을 확인했을 때 해당 타입이 아닌 `object`라는 결과가 반환된다는 것이다.
- 정수와 실수를 구분해 저장하는 다른 언어와 다르게, 자바스크립트는 모든 숫자를 하나의 타입(Number)에 저장했었다.
- BigInt는 ES2020에서 새롭게 나온 것으로 number의 한계를 넘어서 더 큰 숫자를 저장할 수 있게 해준다.
- 자바스크립트 문자열의 특징 중 하나는 문자열이 원시타입이며 변경 불가능하다는 것이다. 한번 문자열이 생성되면 그 문자열은 변경할 수 없다.
- 객체 타입을 간단하게 정의하면 앞서 7가지 원시타입 이외의 모든 것, 즉 자바스크립트를 이루고 있는 대부분의 타입이 바로 객체타입ㄴ이다.
- 한 가지 주목할 것은 객체타입(obejct type)은 참조를 전달한다고 해서 참조타입으로도 불린다는 사실이다. (동등비교 관련해서 중요)
- == 비교는 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환을 한 후에 변경한다.
- Object.is 는 비교전 타입변환 작업을 하지않는다. 타입이 다르면 그냥 false 다. Object.is()와 ===는 NaN 값과 부호 있는 \(0\)을 다르게 처리한다는 점에서 차이가 있다.
- 리액트에서 비교를 요약하면 Object.is 로 먼저 비교를 수행한 다음에 Object.is에서 수행하지 못하는 비교, 즉 객체간 얕은 비교를 한 번 더 수행하는 것을 알 수 있다. 이러한 특성을 안다면 props에 또다른 객체를 넘겨준다면 리액트 렌더링이 예상치 못하게 작동한다는 것을 알 수 있다.
- 이와같이 props가 깊어지는 경우, 즉 한 객체 안에 또다른 객체가 있을 경우 Reac.memo는 컴포넌트에 실제로 변경된 값이 없음에도 불구하고 메모이제이션된 컴포넌트를 반환하지 못한다.
- 함수표현식에서는 할당하려는 함수의 이름을 생략하는 것이 일반적이다. 그 이유는 코드를 봤을 때 혼란을 방지하기 위함이다.
- 함수의 호이스팅은 함수에 대한 선언을 실행 전에 미리 메모리에 등록하느 작업을 의미한다. 이러한 함수의 호이스팅이라는 특징 덕분에 함수 선언문이 이미 메모리에 등록됐고, 코드 순서 상관없이 정상적으로 함수 호출이 가능해진다.
- 함수와 다르게 변수는 런타임 이전에 undefined로 초기화되고 할당문이 실행되는 싲ㅁ, 즉 런타임 시점에 함수가 할당되어 작동한다는 것을 알 수 있다.
- 화살표 함수와 일반 함수의 가장 큰 차이점은 바로 this 바인딩이다. 일반함수에서의 this는 전역객체를 가리게되지만 화살표함수는 함수 자체의 바인딩을 가지지 않고 상위스코프의 this를 그대로 따르게 된다.
- 화살표 함수는 this가 선언되는 시점에 이미 상위 스코프로 결정되어 있고 일반 함수는 호출하는 런타임 시점에 결정되는 this를 따른다.
- 즉시 실행함수는 어디서든 다시금 호출되지 않는다는 점을 각인시킬 수 있어 리팩터링에도 매우 도움이 된다. 일단 선언돼 있으면 어디서 쓸지 모르는 일반 함수와는 다르게, 즉시 실행함수는 그 선언만으로도 실행이 거기서 끝난다는 것을 각인시킬 수 있기 때문이다.
- 부수효과를 만드는 것은 애플리케이션을 만들면서 피할 수 없는 요소지만 이러한 부수 효과를 최대한 억제할 수 있는 방향으로 함수를 설계해야한다.
- 리액트의 관점에서 본다면 부수효과를 처리하는 훅인 useEffect의 작동을 최소화 하는 것이 그 일환이라 할 수 있다.
- 
- 
