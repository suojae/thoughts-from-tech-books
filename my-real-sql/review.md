<img width="400" height="513" alt="image" src="https://github.com/user-attachments/assets/516110c9-14c2-4dc6-b25a-4762f6615053" />

<br/>

## 3. 아키텍쳐 
- MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에게 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러 요청이라고 하고, 여기서 사용되는 API를 핸들러 API라고 한다.
- MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 크게 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있다.
- 포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재하며 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리하는 것이 임무다.
- 포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.
- InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.
- InnoDB에서도 데이터를 읽는 작업은 주로 클라스레드에서 처리되기 때문에 읽기 스레드는 많이 설정할 필요가 없지만 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 충분히 해당 스토리지 장비가 활용될 수 있게 하는 것이 좋다.
- SQL 처리 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다.
- MySQL에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.
- 글로벌 메모리는 일반적으로 클라이언트 스레스 수와 무관하게 하나의 메모리 공간이 할당되고 각 스레드가 공유한다.
- 로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이있다.
- `Handler`로 시작되는 상태변수는 MySQL 엔진이 각 스토리지 엔진에게 보낸 명령의 횟수를 의미하는 변수라고 이해하면 된다.

<img width="400" alt="image" src="https://github.com/user-attachments/assets/71cbc793-ad76-4b2e-bee0-1fdac4a02269" />

- 중요한 점은 하나의 쿼리작업은 여러 하위 작업으로 나뉘는데 각 하위작업이 MySQL엔진 영역에서 처리되는지 아니면 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야한다는 점이다.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/3a4a305d-a0b0-40fd-a0f9-e44863d4d47b" />

- MySQL의 복제는 레플리케이션이라고도 하는데 2대 이상의 MySQL 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술이다.
- MySQL에서는 쓰기와 읽기의 역할로 구분해 전자를 마스터라고 하고 후자를 슬레이브라고 한다.
- 마스터는 애플리케이션의 입장에서 본다면 주로 데이터가 생성 및 변경, 삭제되는 주체(시작점)라고 볼 수 있다.
- 슬레이버 서버의 I/O 스레드는 마스터 서버에 접속해 변경내역(바이너리 로그)를 요청하고 받아온 내역을 릴레이 로그에 기록한다. 그리고 슬레이브 서버에서 릴레이 로그를 재실행함으로써 마스터와 동일한 상태를 유지한다.
- 쿼리 캐시는 단어의 의미와 달리 SQL문장을 캐시하는 것이 아닌 쿼리 결과를 메모리에 캐시해 두는 기능이다.
- 쿼리 결과가 쿼리 캐시에 저장된 이후 데이터가 변겨오디면 어떻게 될까? 당연히 이미 변경된 데이터를 캐시하는 것은 의미가 없기 때문에 데이터를 제거(무효화)해야한다.
- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다.
- InnoDB 스토리지 엔진은 MVCC라는 기술을 이용해 락을 걸지 않고 읽기 작업을 수행한다. 락을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 락을 기다리지도 않는다.
- 일반적으로 전체 장착된 물리 메모리의 50-80% 수준에서 버퍼 풀의 메모리 크기를 결정한다.
- Undo의 데이터는 크게 두 가지 용도로 사용되는데, 첫번째 용도가 바로 위에서 언급한 트랜잭션의 롤백 대비용이다. 두번째 용도는 트랜잭션의 격리수준을 유지함ㄴ서 높은 동시성을 제공하는데 사용된다.
- InnoDB는 변경해야할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만 그렇지 않고 디스크로부터 읽어와서 업데이트를 해야한다면 이를 즉시 실행하지 않고 임시 공간에 저장해두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 되는데 이때 사용하는 임시 메모리 공간을 인서트 버퍼(insert buffer)라고 한다.

<br/>

